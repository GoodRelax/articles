---
layout: default
title: "The Soul of Software Lives in Its Names — Kotodama"
date: 2026-01-31
lang: en
key: Naming_01
tags: [softwareengineering, cleancode, programming, philosophy, ai]
---

## Index
* Table of Contents
{:toc}

---

# The Soul of Software Lives in Its Names — Kotodama

**Kotodama (言霊)** is an ancient Japanese concept suggesting that words possess spiritual power.

In modern Japan, the term is rarely discussed in daily life. Most people are not deeply religious; we simply respect traditions and enjoy Christmas, Halloween, and New Year’s shrine visits as cultural rituals.

So why talk about _Kotodama_ in software engineering?

Because this concept isn't about mysticism. It expresses a fundamental truth about how we build systems.

We have countless principles for great software: **KISS, YAGNI, DRY, SOLID, SoC, SLAP, CQS.** But beneath all of them lies a single practice that quietly determines the destiny of a codebase:

**Naming.**

## Good naming creates readable code, reduces bugs, and allows software to evolve.

### The Hilbert Perspective vs. The Human Perspective

The great mathematician David Hilbert once said:

> "It does not matter if we call the things chairs, tables and beer mugs or points, lines and planes."

In mathematics, objects function correctly regardless of their labels, provided the logic and structure are consistent.

Software is technically the same. A program executes whether you name a class `X`, `Foo`, or `PaymentProcessor`. The compiler does not care.

**But humans do.**

Poor naming makes code impenetrable. Efficient development relies on a shared mental model. When we read a variable name, we aren't just reading text; we are invoking an idea.

In this sense: **The soul of software lives in its names.**

---

### Kotodama in the Modern Stack

Interestingly, the concept of _Kotodama_ mirrors this idea perfectly.

- **Intent:** Parents name children with hopes for their future. In code, we name variables to define their purpose.
- **Encapsulation:** In ancient Japan, people had "true names" (_imina_ / _mana_) that were kept hidden to protect them. This is surprisingly similar to object-oriented programming, where we hide private state behind meaningful abstractions.

Words matter. Names carry intent, structure, and understanding.

That is **Kotodama** in software.

Even in the age of AI, names are more important than ever. High-quality prompts with precise naming produce significantly better code. AI doesn't just process logic; it processes the semantics we provide.

### The GR Naming Cheat Sheet

To help developers harness this power, I created the **GR Naming Cheat Sheet**.
    
    * [English](https://goodrelax.github.io/gr-cheat-sheets/naming/naming_en.html)
    * [Japanes](https://goodrelax.github.io/gr-cheat-sheets/naming/naming_jp.html)

When you are struggling to find the right name, this table may help you.
I hope this sheet improves your code — and that your software makes everyone, including me, a little happier.

References:
- [https://en.wikipedia.org/wiki/Kotodama](https://en.wikipedia.org/wiki/Kotodama)
- [https://en.wikipedia.org/wiki/Finitary](https://en.wikipedia.org/wiki/Finitary)
